# 14 — 路径系统指南

---

## 1. 概述

路径系统（PathManager）是 PNNE 中管理节点层次结构的核心组件。它提供了类似文件系统的路径机制，用于唯一标识和访问节点图中的任何节点。

### 1.1 核心概念

- **绝对路径**: 从根路径开始的完整路径（如 `/obj/subnet1/conv1`）
- **相对路径**: 相对于当前位置的路径（如 `../conv1` 或 `./subnet1/relu`）
- **路径规范化**: 自动处理重复斜杠、末尾斜杠等问题
- **层次结构**: 支持嵌套的节点图和子图

### 1.2 路径格式

```
基本格式: /[context]/[parent]/[..]/[node_name]
引脚路径: /[node_path].[pin_name]

示例:
/obj/conv1                    # 节点路径
/obj/subnet1/conv2.output    # 引脚路径
/train/dataset               # 训练上下文中的节点
```

---

## 2. PathManager API

### 2.1 路径解析

#### parse_path(path: str) -> Tuple[str, Optional[str]]

解析路径为节点路径和引脚名称。

```python
from core.base.path_manager import PathManager

# 解析节点路径
node_path, pin_name = PathManager.parse_path("/obj/conv1")
# 结果: ("/obj/conv1", None)

# 解析引脚路径
node_path, pin_name = PathManager.parse_path("/obj/conv1.output")
# 结果: ("/obj/conv1", "output")

# 处理多个点（最后一个点被视为引脚分隔符）
node_path, pin_name = PathManager.parse_path("/obj/subnet.1/conv.2.output")
# 结果: ("/obj/subnet.1/conv.2", "output")
```

### 2.2 路径规范化

#### normalize_path(path: str) -> str

规范化路径，移除重复斜杠、末尾斜杠等。

```python
# 添加开头斜杠
PathManager.normalize_path("obj/conv1")
# 结果: "/obj/conv1"

# 移除重复斜杠
PathManager.normalize_path("//obj//conv1//")
# 结果: "/obj/conv1"

# 根路径保持为 "/"
PathManager.normalize_path("///")
# 结果: "/"
```

### 2.3 路径连接

#### join_path(*parts: str) -> str

连接多个路径部分为完整路径。

```python
# 连接路径部分
PathManager.join_path("/obj", "subnet1", "conv1")
# 结果: "/obj/subnet1/conv1"

# 自动过滤空字符串
PathManager.join_path("/obj", "", "conv1")
# 结果: "/obj/conv1"

# 空部分返回根路径
PathManager.join_path()
# 结果: "/"
```

### 2.4 路径层次操作

#### get_parent_path(path: str) -> Optional[str]

获取父路径。

```python
# 嵌套路径
PathManager.get_parent_path("/obj/subnet1/conv1")
# 结果: "/obj/subnet1"

# 顶级路径
PathManager.get_parent_path("/obj")
# 结果: "/"

# 根路径没有父路径
PathManager.get_parent_path("/")
# 结果: None
```

#### get_node_name(path: str) -> str

从路径中提取节点名称。

```python
PathManager.get_node_name("/obj/subnet1/conv1")
# 结果: "conv1"

PathManager.get_node_name("/obj")
# 结果: "obj"

PathManager.get_node_name("/")
# 结果: ""
```

#### is_descendant(ancestor_path: str, descendant_path: str) -> bool

检查一个路径是否是另一个路径的后代。

```python
# 正确的后代关系
PathManager.is_descendant("/obj", "/obj/subnet1/conv1")
# 结果: True

# 兄弟节点不是后代
PathManager.is_descendant("/obj/subnet1", "/obj/subnet2/conv1")
# 结果: False

# 相同路径不是后代
PathManager.is_descendant("/obj/subnet1", "/obj/subnet1")
# 结果: False
```

### 2.5 路径验证

#### validate_path(path: str) -> bool

验证路径格式是否正确。

```python
# 有效路径
PathManager.validate_path("/obj/conv1")
# 结果: True

# 无效路径：没有开头斜杠
PathManager.validate_path("obj/conv1")
# 结果: False

# 无效路径：包含非法字符
PathManager.validate_path("/obj\\conv1")  # 反斜杠
PathManager.validate_path("/obj?conv1")   # 问号
# 结果: False

# 无效路径：双斜杠
PathManager.validate_path("/obj//conv1")
# 结果: False
```

#### is_absolute_path(path: str) -> bool

检查是否为绝对路径。

```python
PathManager.is_absolute_path("/obj/conv1")
# 结果: True

PathManager.is_absolute_path("obj/conv1")
# 结果: False

PathManager.is_absolute_path("./obj/conv1")
# 结果: False
```

### 2.6 相对路径解析

#### resolve_relative_path(base_path: str, relative_path: str) -> str

解析相对路径为绝对路径。

```python
# 父目录相对路径
PathManager.resolve_relative_path("/obj/subnet1", "../conv1")
# 结果: "/obj/conv1"

# 当前目录相对路径
PathManager.resolve_relative_path("/obj", "./subnet1/conv1")
# 结果: "/obj/subnet1/conv1"

# 绝对路径直接返回
PathManager.resolve_relative_path("/obj", "/train/dataset")
# 结果: "/train/dataset"

# 多级父目录
PathManager.resolve_relative_path("/obj/subnet1/subnet2", "../../conv1")
# 结果: "/obj/conv1"

# 超出根目录停留在根
PathManager.resolve_relative_path("/obj", "../..")
# 结果: "/"
```

### 2.7 节点查找

#### find_node(root_graph: NodeGraph, path: str) -> Optional[Node]

在节点图中查找节点。

```python
from core.base.node_graph import NodeGraph
from core.base.path_manager import PathManager

graph = NodeGraph("root")

# 查找节点
node = PathManager.find_node(graph, "/conv1")

# 路径会自动规范化
node = PathManager.find_node(graph, "//conv1//")
# 等价于查找 "/conv1"
```

---

## 3. NodeGraph 集成

### 3.1 获取节点

NodeGraph 的 [`get_node()`](../core/base/node_graph.py:104) 方法使用 PathManager 进行路径规范化：

```python
graph = NodeGraph("root")

# 添加节点
node1 = MyNode(name="conv1")
graph.add_node(node1)

# 使用路径获取节点
found = graph.get_node("/conv1")
found = graph.get_node("//conv1//")  # 自动规范化
found = graph.get_node("conv1")      # 自动添加 /
```

### 3.2 获取节点路径

使用 [`get_node_path()`](../core/base/node_graph.py:417) 方法获取节点的完整路径：

```python
path = graph.get_node_path(node1)
# 结果: "/conv1"

# 在嵌套图中
parent_graph = NodeGraph("parent")
child_graph = NodeGraph("child", parent=parent_graph)
child_graph.add_node(node1)

path = child_graph.get_node_path(node1)
# 结果: "/parent/child/conv1"
```

### 3.3 列出所有节点路径

使用 [`list_node_paths()`](../core/base/node_graph.py:434) 方法列出所有节点：

```python
# 只列出当前图的节点
paths = graph.list_node_paths(include_subgraphs=False)

# 包含子图中的节点
paths = graph.list_node_paths(include_subgraphs=True)
```

---

## 4. 路径规则

### 4.1 命名规则

| 规则 | 说明 | 示例 |
|------|------|------|
| 路径分隔符 | 使用 `/` | `/obj/subnet1/conv1` |
| 引脚分隔符 | 使用 `.` | `/obj/conv1.output` |
| 节点名称 | 同一父节点下必须唯一 | ✓ `/obj/conv1`, `/obj/conv2`<br>✗ `/obj/conv1`, `/obj/conv1` |
| 非法字符 | 不允许 `\`, `?`, `*`, `|`, `<`, `>`, `"`, `:` | ✗ `/obj\conv1`<br>✗ `/obj?conv1` |
| 空节点名 | 不允许连续 `//` | ✗ `/obj//conv1` |

### 4.2 根路径

系统中定义了三个主要的根路径上下文：

| 路径 | 用途 | 说明 |
|------|------|------|
| `/obj/` | 模型空间 | 存放网络结构节点（nn.Module） |
| `/vis/` | 可视化空间 | 存放可视化相关节点 |
| `/train/` | 训练空间 | 存放训练配置节点 |

### 4.3 自动命名

当创建节点未指定名称时，系统会自动生成递增名称：

```python
# 自动生成 conv2d1, conv2d2, conv2d3 ...
node1 = Conv2dNode()  # 自动命名为 "conv2d1"
node2 = Conv2dNode()  # 自动命名为 "conv2d2"
```

---

## 5. 最佳实践

### 5.1 使用场景

✅ **推荐使用路径的场景**：

- 序列化和反序列化节点图
- 在表达式中引用其他节点的输出
- 实现节点间的动态依赖
- 构建复杂的子图结构
- 实现节点的搜索和过滤功能

❌ **不推荐使用路径的场景**：

- 频繁的节点访问（使用直接引用更高效）
- 临时的节点操作（使用节点对象）
- UI 交互（使用节点 ID）

### 5.2 性能考虑

```python
# ✅ 好的做法：缓存节点引用
node = graph.get_node("/obj/conv1")
for i in range(1000):
    value = node.get_output_value("output")

# ❌ 差的做法：重复路径查找
for i in range(1000):
    node = graph.get_node("/obj/conv1")
    value = node.get_output_value("output")
```

### 5.3 错误处理

```python
from core.base.path_manager import PathManager

# 验证路径格式
path = user_input_path
if not PathManager.validate_path(path):
    raise ValueError(f"Invalid path format: {path}")

# 查找节点时处理 None
node = PathManager.find_node(graph, path)
if node is None:
    raise ValueError(f"Node not found: {path}")

# 解析路径时检查结果
node_path, pin_name = PathManager.parse_path(path)
if pin_name is not None:
    # 处理引脚路径
    pass
```

### 5.4 路径构建

```python
# ✅ 推荐：使用 join_path
path = PathManager.join_path("/obj", subnet_name, node_name)

# ❌ 不推荐：手动字符串拼接（可能产生双斜杠）
path = f"/obj/{subnet_name}/{node_name}"

# ✅ 推荐：使用 normalize_path 确保正确性
path = PathManager.normalize_path(user_input_path)

# ❌ 不推荐：假设输入已经规范化
path = user_input_path
```

---

## 6. 常见问题

### Q1: 路径中可以包含中文吗？

**A**: 可以。路径系统支持 Unicode 字符，但为了兼容性建议使用英文。

```python
# 支持中文路径
PathManager.validate_path("/对象/卷积层1")  # True

# 但推荐使用英文
PathManager.validate_path("/obj/conv1")  # True
```

### Q2: 如何处理路径中的空格？

**A**: 路径可以包含空格，但不推荐。建议使用下划线或驼峰命名。

```python
# 可以但不推荐
"/obj/my node 1"

# 推荐做法
"/obj/my_node_1"
"/obj/myNode1"
```

### Q3: 如何遍历整个节点树？

**A**: 使用 [`list_node_paths()`](../core/base/node_graph.py:434) 配合递归：

```python
def traverse_graph(graph: NodeGraph, callback):
    """遍历节点图并对每个节点执行回调"""
    paths = graph.list_node_paths(include_subgraphs=True)
    for path in paths:
        node = graph.get_node(path)
        if node:
            callback(node, path)

# 使用示例
traverse_graph(root_graph, lambda node, path: print(f"{path}: {node.node_type}"))
```

### Q4: 路径系统是否线程安全？

**A**: PathManager 的静态方法是无状态的，因此是线程安全的。但 NodeGraph 的操作需要外部同步。

```python
import threading

# PathManager 方法线程安全
lock = threading.Lock()

def safe_find_node(graph, path):
    # PathManager.normalize_path 线程安全
    normalized = PathManager.normalize_path(path)
    
    # 但 graph.get_node 需要加锁
    with lock:
        return graph.get_node(normalized)
```

### Q5: 如何实现节点路径的重命名？

**A**: 路径是根据节点名称动态生成的，只需修改节点名称：

```python
# 修改节点名称会自动更新路径
node.name = "new_name"

# 新路径会反映在 node.path 属性中
print(node.path)  # "/obj/new_name"
```

---

## 7. 示例代码

### 7.1 创建嵌套节点图

```python
from core.base.node_graph import NodeGraph
from core.base.path_manager import PathManager

# 创建主图
root = NodeGraph("root")

# 创建子图
obj_graph = NodeGraph("obj", parent=root)
root.subgraphs["obj"] = obj_graph

# 创建子子图
subnet1 = NodeGraph("subnet1", parent=obj_graph)
obj_graph.subgraphs["subnet1"] = subnet1

# 添加节点
node = MyNode(name="conv1")
subnet1.add_node(node)

# 节点的完整路径
print(subnet1.get_node_path(node))  # "/root/obj/subnet1/conv1"
```

### 7.2 路径搜索和过滤

```python
def find_nodes_by_pattern(graph: NodeGraph, pattern: str) -> List[Node]:
    """根据路径模式查找节点"""
    import re
    
    results = []
    paths = graph.list_node_paths(include_subgraphs=True)
    
    for path in paths:
        if re.search(pattern, path):
            node = graph.get_node(path)
            if node:
                results.append(node)
    
    return results

# 使用示例
conv_nodes = find_nodes_by_pattern(root, r"conv\d+")
```

### 7.3 构建路径索引

```python
class PathIndex:
    """路径索引，加速节点查找"""
    
    def __init__(self, graph: NodeGraph):
        self.graph = graph
        self.rebuild()
    
    def rebuild(self):
        """重建索引"""
        self._index = {}
        paths = self.graph.list_node_paths(include_subgraphs=True)
        
        for path in paths:
            node = self.graph.get_node(path)
            if node:
                self._index[path] = node
    
    def find(self, path: str) -> Optional[Node]:
        """快速查找节点"""
        normalized = PathManager.normalize_path(path)
        return self._index.get(normalized)

# 使用示例
index = PathIndex(root_graph)
node = index.find("/obj/conv1")  # O(1) 查找
```

---

*文档版本: v1.0*  
*最后更新: 2026-02-17*
